# ===== A0. 环境 =====
suppressPackageStartupMessages({
  library(DBI); library(duckdb); library(data.table); library(stringr)
})

# ===== A1. 连接 DuckDB（内存友好）=====
con <- dbConnect(duckdb::duckdb(), dbdir=":memory:", read_only=TRUE)
# 不要设 threads=auto（DuckDB 需要 INT）；给个保守整数
DBI::dbExecute(con, "PRAGMA threads=4;")
# 适度内存上限（按机器可用内存调整）
DBI::dbExecute(con, "PRAGMA memory_limit='8GB';")

# ===== A2. 帮助函数：将 Windows 路径统一为正斜杠 =====
norm_path <- function(p) gsub("\\\\", "/", p)

# ===== A3. 抽取列名（得到 cols）=====
get_cols <- function(con, parquet_path){
  sql <- sprintf("SELECT * FROM read_parquet('%s') LIMIT 0", norm_path(parquet_path))
  df0 <- dbGetQuery(con, sql)   # 0 行但有列
  names(df0)
}

# ===== A4. 选择列（不区分大小写，找第一个命中）=====
pick_col <- function(cols, candidates){
  # cols: 字符向量（实际列名）；candidates: 可能的列名集合（大小写不敏感）
  ci <- tolower(cols)
  for (cand in candidates){
    hit <- which(ci == tolower(cand))
    if (length(hit)) return(cols[hit[1]])
  }
  return(NA_character_)
}

# ===== A5. 统一把 AGE 转成年龄（岁）=====
age_to_years_sql <- function(age_col, age_cod_col){
  # 生成 DuckDB SQL 片段（CASE WHEN ... END），单位换算健壮
  sprintf("
    CASE
      WHEN TRY_CAST(NULLIF(CAST(%1$s AS VARCHAR), '') AS DOUBLE) IS NULL THEN NULL
      WHEN UPPER(COALESCE(%2$s,'')) IN ('','YR','YRS','YEAR','YEARS') THEN TRY_CAST(NULLIF(CAST(%1$s AS VARCHAR), '') AS DOUBLE)
      WHEN UPPER(%2$s) IN ('MON','MONTH','MONTHS') THEN TRY_CAST(NULLIF(CAST(%1$s AS VARCHAR), '') AS DOUBLE)/12.0
      WHEN UPPER(%2$s) IN ('WK','WEEK','WEEKS')   THEN TRY_CAST(NULLIF(CAST(%1$s AS VARCHAR), '') AS DOUBLE)/52.0
      WHEN UPPER(%2$s) IN ('DY','DAY','DAYS')     THEN TRY_CAST(NULLIF(CAST(%1$s AS VARCHAR), '') AS DOUBLE)/365.25
      WHEN UPPER(%2$s) IN ('DEC','DECADE')        THEN TRY_CAST(NULLIF(CAST(%1$s AS VARCHAR), '') AS DOUBLE)*10.0
      ELSE NULL
    END
  ", age_col, age_cod_col)
}

# ===== A6. 文本字段统一大写（用于 LIKE 匹配）=====
upper_coalesce <- function(col) sprintf("UPPER(COALESCE(%s,''))", col)

# ===== A7. 关键：PS+SS 暴露来源优先级（严格口径）=====
# 我们优先使用“已预聚合好且仅含 PS+SS 的长文本字段”（例如 ALL_DRUGS_PS_SS 或类似命名）。
# 若不存在，则从逐药物行表中，筛选 ROLE ∈ ('PS','SS') 再聚合到病例/报告级。
# 若两者都缺失 → 直接 QC 报错，不走 ALL_DRUGS（因为那通常含 C/I/OT，会污染 PS+SS 口径）。
build_exposure_sql <- function(cols, dict_vec, 
                               case_key, # 'primaryid' 或 'ID'
                               all_drugs_psss_col = NA, # 如 'ALL_DRUGS_PS_SS'
                               drugname_col = NA, role_col = NA){
  # dict_vec: 某一类别的关键词（已大写）
  like_or <- paste(sprintf("%s LIKE '%%%s%%'", "drug_blob", gsub("'", "''", toupper(dict_vec))), collapse=" OR ")
  if (!is.na(all_drugs_psss_col)) {
    # 直接在该字段中做 LIKE（report/case 粒度的拼接字段）
    sql <- sprintf("
      SELECT %1$s AS case_key,
             CASE WHEN (%2$s) THEN 1 ELSE 0 END AS flag
      FROM tmp_base
    ",
                   case_key,
                   paste(sprintf("%s LIKE '%%%s%%'", upper_coalesce(all_drugs_psss_col), gsub("'", "''", toupper(dict_vec))), collapse=" OR ")
    )
    return(sql)
  }
  # 走逐药物行：需要 drugname_col + role_col
  if (is.na(drugname_col) || is.na(role_col)) {
    stop("PS+SS 口径需要：存在 ALL_DRUGS_PS_SS（或同义），或具备逐药物行的 drugname + role 列。当前两者均不可用。")
  }
  # 基于逐药物行构造一张“role ∈ (PS,SS) 的药物文本”子表，再按 case_key 聚合
  # 为避免扫描多次，主流程会先构建 tmp_drugs_psss（见后续 B 段）
  sql <- sprintf("
    SELECT %1$s AS case_key,
           CASE WHEN (%2$s) THEN 1 ELSE 0 END AS flag
    FROM (
      SELECT %1$s, STRING_AGG(%3$s, '|') AS drug_blob
      FROM tmp_drugs_psss
      GROUP BY %1$s
    )
  ",
                 case_key,
                 like_or,
                 upper_coalesce(drugname_col)
  )
  sql
}
FAERS_FILE <- "D:/FAERS/MASTER files/FAERS_MASTER_FILE_2004-2024_with_serious.parquet"
OUT_DIR    <- "D:/FAERS/Inhibitors"; if (!dir.exists(OUT_DIR)) dir.create(OUT_DIR, TRUE)

# 线程/内存/溢写
DBI::dbExecute(con, "PRAGMA threads=2;")
DBI::dbExecute(con, "PRAGMA memory_limit='4GB';")
DBI::dbExecute(con, "PRAGMA temp_directory='D:/duck_tmp';")  # 先确保该目录已创建
DBI::dbExecute(con, "PRAGMA preserve_insertion_order=false;")


# ===== B1. 基础表（FAERS） =====

# 工具：缺失列 → NULL
sql_or_null_as <- function(colname, alias) {
  if (is.na(colname)) sprintf("NULL AS %s", alias) else colname
}

sql_base <- sprintf("
  CREATE OR REPLACE VIEW tmp_base AS
  SELECT
    %s AS case_key,                       -- 主键
    %s AS event_dt,                       -- 事件日期
    %s,                                   -- OCCR_COUNTRY 或 NULL
    %s,                                   -- REPORTER_COUNTRY 或 NULL
    %s AS sex_raw,                        -- 性别
    %s AS age_raw,                        -- 年龄
    %s                                    -- 年龄单位/编码
  FROM read_parquet('%s')
",
                    col_id,
                    col_eventdt,
                    sql_or_null_as(col_occr,   "occr_country"),
                    sql_or_null_as(col_report, "reporter_country"),
                    col_sex,
                    col_age,
                    sql_or_null_as(col_agecod, "age_cod"),
                    norm_path(FAERS_FILE)   # 这里用 FAERS_FILE，已经在上游定义过
)

DBI::dbExecute(con, sql_base)

# QC：确认 tmp_base 是否建好
DBI::dbGetQuery(con, "PRAGMA table_info('tmp_base')")
DBI::dbGetQuery(con, "SELECT COUNT(*) FROM tmp_base")
# ===== B2. 构建 PS+SS 药物视图 & 年/国家代表值视图 =====

# 1) 逐药物行里筛 PS/SS（仅取必要列；大小写统一）
stopifnot(!is.na(col_drugnm), !is.na(col_role))
DBI::dbExecute(con, sprintf("
  CREATE OR REPLACE VIEW tmp_drugs_psss AS
  SELECT
    %1$s AS case_key,
    %2$s AS drugname,
    %3$s AS role_cod
  FROM read_parquet('%4$s')
  WHERE UPPER(COALESCE(%3$s,'')) IN ('PS','SS')
", col_id, col_drugnm, col_role, norm_path(FAERS_FILE)))

# 2) 从 B1 的 tmp_base 派生 year/country_use，并保留性别/年龄原始列
DBI::dbExecute(con, "
  CREATE OR REPLACE VIEW tmp_with_year_country AS
  SELECT
    case_key,
    CASE
      WHEN LENGTH(CAST(event_dt AS VARCHAR))=8
           AND regexp_matches(CAST(event_dt AS VARCHAR),'^[0-9]{8}$')
      THEN TRY_CAST(SUBSTR(CAST(event_dt AS VARCHAR),1,4) AS INTEGER)
      ELSE NULL
    END AS year,
    CASE
      WHEN occr_country IS NOT NULL AND occr_country <> '' THEN occr_country
      ELSE reporter_country
    END AS country_use,
    sex_raw,
    age_raw,
    age_cod
  FROM tmp_base
")

# ---- QC（简短）----
DBI::dbGetQuery(con, "SELECT COUNT(*) AS n_psss FROM tmp_drugs_psss")
DBI::dbGetQuery(con, "SELECT COUNT(*) AS n_cases FROM tmp_with_year_country")
DBI::dbGetQuery(con, "SELECT * FROM tmp_with_year_country WHERE year IS NOT NULL LIMIT 3")
CNI  <- c("TACROLIMUS","FK506","PROGRAF","ADVAGRAF","CYCLOSPORINE","NEORAL","SANDIMMUNE")
MTOR <- c("EVEROLIMUS","AFINITOR","CERTICAN","SIROLIMUS","RAPAMUNE","TEMSIROLIMUS","TORISEL")
ANTI <- c("MYCOPHENOLATE MOFETIL","CELLCEPT","MYCOPHENOLIC ACID","MYFORTIC","AZATHIOPRINE","IMURAN")
CS   <- c("PREDNISONE","DELTASONE","METHYLPREDNISOLONE","MEDROL","SOLU-MEDROL","DEXAMETHASONE","DECADRON","PREDNISOLONE")
BIO  <- c("RITUXIMAB","MABTHERA","RITUXAN","BASILIXIMAB","SIMULECT","BELATACEPT","NULOJIX")
like_or <- function(vec) paste(sprintf("UPPER(COALESCE(d.drugname,'')) LIKE '%%%s%%'", gsub("'", "''", vec)), collapse=" OR ")
DBI::dbExecute(con, sprintf("
  CREATE OR REPLACE TABLE flag_cni AS
  SELECT DISTINCT c.case_key, 1 AS flag
  FROM tmp_with_year_country c
  WHERE EXISTS (SELECT 1 FROM tmp_drugs_psss d WHERE d.case_key=c.case_key AND (%s))
", like_or(CNI)))

DBI::dbExecute(con, sprintf("
  CREATE OR REPLACE TABLE flag_mtor AS
  SELECT DISTINCT c.case_key, 1 AS flag
  FROM tmp_with_year_country c
  WHERE EXISTS (SELECT 1 FROM tmp_drugs_psss d WHERE d.case_key=c.case_key AND (%s))
", like_or(MTOR)))

DBI::dbExecute(con, sprintf("
  CREATE OR REPLACE TABLE flag_anti AS
  SELECT DISTINCT c.case_key, 1 AS flag
  FROM tmp_with_year_country c
  WHERE EXISTS (SELECT 1 FROM tmp_drugs_psss d WHERE d.case_key=c.case_key AND (%s))
", like_or(ANTI)))

DBI::dbExecute(con, sprintf("
  CREATE OR REPLACE TABLE flag_cs AS
  SELECT DISTINCT c.case_key, 1 AS flag
  FROM tmp_with_year_country c
  WHERE EXISTS (SELECT 1 FROM tmp_drugs_psss d WHERE d.case_key=c.case_key AND (%s))
", like_or(CS)))

DBI::dbExecute(con, sprintf("
  CREATE OR REPLACE TABLE flag_bio AS
  SELECT DISTINCT c.case_key, 1 AS flag
  FROM tmp_with_year_country c
  WHERE EXISTS (SELECT 1 FROM tmp_drugs_psss d WHERE d.case_key=c.case_key AND (%s))
", like_or(BIO)))

# QC（每类应 >0）
DBI::dbGetQuery(con, "SELECT (SELECT COUNT(*) FROM flag_cni) cni,
                             (SELECT COUNT(*) FROM flag_mtor) mtor,
                             (SELECT COUNT(*) FROM flag_anti) anti,
                             (SELECT COUNT(*) FROM flag_cs)   cs,
                             (SELECT COUNT(*) FROM flag_bio)  bio")
DBI::dbGetQuery(con, "
  SELECT 'cni'  AS cat, COUNT(*) AS n FROM flag_cni
  UNION ALL
  SELECT 'mtor', COUNT(*) FROM flag_mtor
  UNION ALL
  SELECT 'anti', COUNT(*) FROM flag_anti
  UNION ALL
  SELECT 'cs',   COUNT(*) FROM flag_cs
  UNION ALL
  SELECT 'bio',  COUNT(*) FROM flag_bio
  ORDER BY cat
")
DBI::dbExecute(con, "
  CREATE OR REPLACE TABLE faers_case_psss AS
  SELECT c.*, COALESCE(f.flag,0) AS flag_cni
  FROM tmp_with_year_country c LEFT JOIN flag_cni f USING(case_key);
")
DBI::dbExecute(con, "
  CREATE OR REPLACE TABLE faers_case_psss AS
  SELECT c.*, COALESCE(m.flag,0) AS flag_mtor
  FROM faers_case_psss c LEFT JOIN flag_mtor m USING(case_key);
")
DBI::dbExecute(con, "
  CREATE OR REPLACE TABLE faers_case_psss AS
  SELECT c.*, COALESCE(a.flag,0) AS flag_anti
  FROM faers_case_psss c LEFT JOIN flag_anti a USING(case_key);
")
DBI::dbExecute(con, "
  CREATE OR REPLACE TABLE faers_case_psss AS
  SELECT c.*, COALESCE(s.flag,0) AS flag_cs
  FROM faers_case_psss c LEFT JOIN flag_cs s USING(case_key);
")
DBI::dbExecute(con, "
  CREATE OR REPLACE TABLE faers_case_psss AS
  SELECT c.*, COALESCE(b.flag,0) AS flag_bio
  FROM faers_case_psss c LEFT JOIN flag_bio b USING(case_key);
")

# QC
DBI::dbGetQuery(con, "SELECT COUNT(*) n FROM faers_case_psss")
DBI::dbGetQuery(con, "SELECT SUM(flag_cni) cni, SUM(flag_mtor) mtor, SUM(flag_anti) anti, SUM(flag_cs) cs, SUM(flag_bio) bio FROM faers_case_psss")
DBI::dbGetQuery(con, '
  SELECT
    SUM(flag_cni)  AS "cni",
    SUM(flag_mtor) AS "mtor",
    SUM(flag_anti) AS "anti",
    SUM(flag_cs)   AS "cs",
    SUM(flag_bio)  AS "bio"
  FROM faers_case_psss
')

# ===== B6. 年龄分布：双轨输出 =====

# 基础 WITH 子句：统一把 age_raw+age_cod 转成年龄（years）
age_sql <- "
  CASE
    WHEN TRY_CAST(NULLIF(CAST(age_raw AS VARCHAR), '') AS DOUBLE) IS NULL THEN NULL
    WHEN UPPER(COALESCE(age_cod,'')) IN ('','YR','YRS','YEAR','YEARS') 
         THEN TRY_CAST(NULLIF(CAST(age_raw AS VARCHAR), '') AS DOUBLE)
    WHEN UPPER(age_cod) IN ('MON','MONTH','MONTHS') 
         THEN TRY_CAST(NULLIF(CAST(age_raw AS VARCHAR), '') AS DOUBLE)/12.0
    WHEN UPPER(age_cod) IN ('WK','WEEK','WEEKS')   
         THEN TRY_CAST(NULLIF(CAST(age_raw AS VARCHAR), '') AS DOUBLE)/52.0
    WHEN UPPER(age_cod) IN ('DY','DAY','DAYS')     
         THEN TRY_CAST(NULLIF(CAST(age_raw AS VARCHAR), '') AS DOUBLE)/365.25
    WHEN UPPER(age_cod) IN ('DEC','DECADE')        
         THEN TRY_CAST(NULLIF(CAST(age_raw AS VARCHAR), '') AS DOUBLE)*10.0
    ELSE NULL
  END
"

# --- 表1：中位数 + IQR ---
age_median <- DBI::dbGetQuery(con, sprintf("
  WITH base AS (
    SELECT %s AS age_years, flag_cni, flag_mtor, flag_anti, flag_cs, flag_bio
    FROM faers_case_psss
  )
  SELECT 'Calcineurin inhibitors' AS drug_category,
         COUNT(age_years) AS N_nonmissing,
         quantile_cont(age_years,0.5)  AS median_age,
         quantile_cont(age_years,0.25) AS q1,
         quantile_cont(age_years,0.75) AS q3
  FROM base WHERE flag_cni=1
  UNION ALL
  SELECT 'mTOR inhibitors', COUNT(age_years), quantile_cont(age_years,0.5), quantile_cont(age_years,0.25), quantile_cont(age_years,0.75)
  FROM base WHERE flag_mtor=1
  UNION ALL
  SELECT 'Antiproliferative agents', COUNT(age_years), quantile_cont(age_years,0.5), quantile_cont(age_years,0.25), quantile_cont(age_years,0.75)
  FROM base WHERE flag_anti=1
  UNION ALL
  SELECT 'Corticosteroids', COUNT(age_years), quantile_cont(age_years,0.5), quantile_cont(age_years,0.25), quantile_cont(age_years,0.75)
  FROM base WHERE flag_cs=1
  UNION ALL
  SELECT 'Biologics', COUNT(age_years), quantile_cont(age_years,0.5), quantile_cont(age_years,0.25), quantile_cont(age_years,0.75)
  FROM base WHERE flag_bio=1
", age_sql))
data.table::fwrite(age_median, "D:/FAERS/Inhibitors/age_median_IQR_by_category_PS+SS.csv")

# --- 表2：均值 ± SD ---
age_mean <- DBI::dbGetQuery(con, sprintf("
  WITH base AS (
    SELECT %s AS age_years, flag_cni, flag_mtor, flag_anti, flag_cs, flag_bio
    FROM faers_case_psss
  )
  SELECT 'Calcineurin inhibitors' AS drug_category,
         COUNT(age_years) AS N_nonmissing,
         avg(age_years)   AS mean_age,
         stddev_samp(age_years) AS sd_age
  FROM base WHERE flag_cni=1
  UNION ALL
  SELECT 'mTOR inhibitors', COUNT(age_years), avg(age_years), stddev_samp(age_years)
  FROM base WHERE flag_mtor=1
  UNION ALL
  SELECT 'Antiproliferative agents', COUNT(age_years), avg(age_years), stddev_samp(age_years)
  FROM base WHERE flag_anti=1
  UNION ALL
  SELECT 'Corticosteroids', COUNT(age_years), avg(age_years), stddev_samp(age_years)
  FROM base WHERE flag_cs=1
  UNION ALL
  SELECT 'Biologics', COUNT(age_years), avg(age_years), stddev_samp(age_years)
  FROM base WHERE flag_bio=1
", age_sql))
data.table::fwrite(age_mean, "D:/FAERS/Inhibitors/age_mean_SD_by_category_PS+SS.csv")

#B7
age_expr <- age_to_years_sql("age_raw","age_cod")

age_stats_faers <- DBI::dbGetQuery(con, sprintf("
  WITH base AS (
    SELECT %s AS age_years, flag_cni, flag_mtor, flag_anti, flag_cs, flag_bio
    FROM faers_case_psss
  )
  SELECT 'Calcineurin inhibitors' AS drug_category, COUNT(age_years) AS N_nonmissing,
         quantile_cont(age_years,0.5)  AS median_age,
         quantile_cont(age_years,0.25) AS q1,
         quantile_cont(age_years,0.75) AS q3
  FROM base WHERE flag_cni=1
  UNION ALL
  SELECT 'mTOR inhibitors', COUNT(age_years),
         quantile_cont(age_years,0.5), quantile_cont(age_years,0.25), quantile_cont(age_years,0.75)
  FROM base WHERE flag_mtor=1
  UNION ALL
  SELECT 'Antiproliferative agents', COUNT(age_years),
         quantile_cont(age_years,0.5), quantile_cont(age_years,0.25), quantile_cont(age_years,0.75)
  FROM base WHERE flag_anti=1
  UNION ALL
  SELECT 'Corticosteroids', COUNT(age_years),
         quantile_cont(age_years,0.5), quantile_cont(age_years,0.25), quantile_cont(age_years,0.75)
  FROM base WHERE flag_cs=1
  UNION ALL
  SELECT 'Biologics', COUNT(age_years),
         quantile_cont(age_years,0.5), quantile_cont(age_years,0.25), quantile_cont(age_years,0.75)
  FROM base WHERE flag_bio=1
", age_expr))

data.table::fwrite(age_stats_faers, "D:/FAERS/Inhibitors/age_stats_by_category_PS+SS.csv")

#B8
sex_dist_faers <- DBI::dbGetQuery(con, "
  WITH sex_std AS (
    SELECT CASE
             WHEN UPPER(COALESCE(sex_raw,'')) IN ('F','FEMALE','2') THEN 'F'
             WHEN UPPER(COALESCE(sex_raw,'')) IN ('M','MALE','1')   THEN 'M'
             ELSE 'Other' END AS sex3,
           flag_cni, flag_mtor, flag_anti, flag_cs, flag_bio
    FROM faers_case_psss
  )
  SELECT 'Calcineurin inhibitors' AS drug_category, sex3, COUNT(*) n FROM sex_std WHERE flag_cni=1 GROUP BY sex3
  UNION ALL SELECT 'mTOR inhibitors', sex3, COUNT(*) FROM sex_std WHERE flag_mtor=1 GROUP BY sex3
  UNION ALL SELECT 'Antiproliferative agents', sex3, COUNT(*) FROM sex_std WHERE flag_anti=1 GROUP BY sex3
  UNION ALL SELECT 'Corticosteroids', sex3, COUNT(*) FROM sex_std WHERE flag_cs=1 GROUP BY sex3
  UNION ALL SELECT 'Biologics', sex3, COUNT(*) FROM sex_std WHERE flag_bio=1 GROUP BY sex3
  ORDER BY drug_category, sex3
")
data.table::fwrite(sex_dist_faers, "D:/FAERS/Inhibitors/sex_distribution_by_category_PS+SS.csv")

#B9
country_dist_faers <- DBI::dbGetQuery(con, "
  SELECT 'Calcineurin inhibitors' AS drug_category, country_use, COUNT(*) case_count
    FROM faers_case_psss WHERE flag_cni=1 AND country_use IS NOT NULL AND country_use<>'' GROUP BY country_use
  UNION ALL SELECT 'mTOR inhibitors', country_use, COUNT(*) FROM faers_case_psss WHERE flag_mtor=1 AND country_use IS NOT NULL AND country_use<>'' GROUP BY country_use
  UNION ALL SELECT 'Antiproliferative agents', country_use, COUNT(*) FROM faers_case_psss WHERE flag_anti=1 AND country_use IS NOT NULL AND country_use<>'' GROUP BY country_use
  UNION ALL SELECT 'Corticosteroids', country_use, COUNT(*) FROM faers_case_psss WHERE flag_cs=1 AND country_use IS NOT NULL AND country_use<>'' GROUP BY country_use
  UNION ALL SELECT 'Biologics', country_use, COUNT(*) FROM faers_case_psss WHERE flag_bio=1 AND country_use IS NOT NULL AND country_use<>'' GROUP BY country_use
  ORDER BY drug_category, case_count DESC
")
data.table::fwrite(country_dist_faers, "D:/FAERS/Inhibitors/country_distribution_by_category_PS+SS.csv")
